// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/shinnosuke-K/github-dev-insight/ent/commits"
	"github.com/shinnosuke-K/github-dev-insight/ent/issue"
	"github.com/shinnosuke-K/github-dev-insight/ent/predicate"
	"github.com/shinnosuke-K/github-dev-insight/ent/pullrequest"
	"github.com/shinnosuke-K/github-dev-insight/ent/repository"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCommits     = "Commits"
	TypeIssue       = "Issue"
	TypePullRequest = "PullRequest"
	TypeRepository  = "Repository"
)

// CommitsMutation represents an operation that mutates the Commits nodes in the graph.
type CommitsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	github_id           *string
	message             *string
	committed_at        *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	pull_request        *uuid.UUID
	clearedpull_request bool
	done                bool
	oldValue            func(context.Context) (*Commits, error)
	predicates          []predicate.Commits
}

var _ ent.Mutation = (*CommitsMutation)(nil)

// commitsOption allows management of the mutation configuration using functional options.
type commitsOption func(*CommitsMutation)

// newCommitsMutation creates new mutation for the Commits entity.
func newCommitsMutation(c config, op Op, opts ...commitsOption) *CommitsMutation {
	m := &CommitsMutation{
		config:        c,
		op:            op,
		typ:           TypeCommits,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommitsID sets the ID field of the mutation.
func withCommitsID(id uuid.UUID) commitsOption {
	return func(m *CommitsMutation) {
		var (
			err   error
			once  sync.Once
			value *Commits
		)
		m.oldValue = func(ctx context.Context) (*Commits, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commits.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommits sets the old Commits of the mutation.
func withCommits(node *Commits) commitsOption {
	return func(m *CommitsMutation) {
		m.oldValue = func(context.Context) (*Commits, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommitsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommitsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commits entities.
func (m *CommitsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommitsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *CommitsMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *CommitsMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the Commits entity.
// If the Commits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommitsMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *CommitsMutation) ResetGithubID() {
	m.github_id = nil
}

// SetMessage sets the "message" field.
func (m *CommitsMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CommitsMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Commits entity.
// If the Commits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommitsMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CommitsMutation) ResetMessage() {
	m.message = nil
}

// SetCommittedAt sets the "committed_at" field.
func (m *CommitsMutation) SetCommittedAt(t time.Time) {
	m.committed_at = &t
}

// CommittedAt returns the value of the "committed_at" field in the mutation.
func (m *CommitsMutation) CommittedAt() (r time.Time, exists bool) {
	v := m.committed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCommittedAt returns the old "committed_at" field's value of the Commits entity.
// If the Commits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommitsMutation) OldCommittedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommittedAt: %w", err)
	}
	return oldValue.CommittedAt, nil
}

// ResetCommittedAt resets all changes to the "committed_at" field.
func (m *CommitsMutation) ResetCommittedAt() {
	m.committed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommitsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommitsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commits entity.
// If the Commits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommitsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommitsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPullRequestID sets the "pull_request" edge to the PullRequest entity by id.
func (m *CommitsMutation) SetPullRequestID(id uuid.UUID) {
	m.pull_request = &id
}

// ClearPullRequest clears the "pull_request" edge to the PullRequest entity.
func (m *CommitsMutation) ClearPullRequest() {
	m.clearedpull_request = true
}

// PullRequestCleared reports if the "pull_request" edge to the PullRequest entity was cleared.
func (m *CommitsMutation) PullRequestCleared() bool {
	return m.clearedpull_request
}

// PullRequestID returns the "pull_request" edge ID in the mutation.
func (m *CommitsMutation) PullRequestID() (id uuid.UUID, exists bool) {
	if m.pull_request != nil {
		return *m.pull_request, true
	}
	return
}

// PullRequestIDs returns the "pull_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PullRequestID instead. It exists only for internal usage by the builders.
func (m *CommitsMutation) PullRequestIDs() (ids []uuid.UUID) {
	if id := m.pull_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPullRequest resets all changes to the "pull_request" edge.
func (m *CommitsMutation) ResetPullRequest() {
	m.pull_request = nil
	m.clearedpull_request = false
}

// Where appends a list predicates to the CommitsMutation builder.
func (m *CommitsMutation) Where(ps ...predicate.Commits) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommitsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Commits).
func (m *CommitsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommitsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.github_id != nil {
		fields = append(fields, commits.FieldGithubID)
	}
	if m.message != nil {
		fields = append(fields, commits.FieldMessage)
	}
	if m.committed_at != nil {
		fields = append(fields, commits.FieldCommittedAt)
	}
	if m.created_at != nil {
		fields = append(fields, commits.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommitsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commits.FieldGithubID:
		return m.GithubID()
	case commits.FieldMessage:
		return m.Message()
	case commits.FieldCommittedAt:
		return m.CommittedAt()
	case commits.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommitsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commits.FieldGithubID:
		return m.OldGithubID(ctx)
	case commits.FieldMessage:
		return m.OldMessage(ctx)
	case commits.FieldCommittedAt:
		return m.OldCommittedAt(ctx)
	case commits.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Commits field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommitsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commits.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case commits.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case commits.FieldCommittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommittedAt(v)
		return nil
	case commits.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Commits field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommitsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommitsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommitsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Commits numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommitsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommitsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommitsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Commits nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommitsMutation) ResetField(name string) error {
	switch name {
	case commits.FieldGithubID:
		m.ResetGithubID()
		return nil
	case commits.FieldMessage:
		m.ResetMessage()
		return nil
	case commits.FieldCommittedAt:
		m.ResetCommittedAt()
		return nil
	case commits.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Commits field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommitsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pull_request != nil {
		edges = append(edges, commits.EdgePullRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommitsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commits.EdgePullRequest:
		if id := m.pull_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommitsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommitsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommitsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpull_request {
		edges = append(edges, commits.EdgePullRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommitsMutation) EdgeCleared(name string) bool {
	switch name {
	case commits.EdgePullRequest:
		return m.clearedpull_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommitsMutation) ClearEdge(name string) error {
	switch name {
	case commits.EdgePullRequest:
		m.ClearPullRequest()
		return nil
	}
	return fmt.Errorf("unknown Commits unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommitsMutation) ResetEdge(name string) error {
	switch name {
	case commits.EdgePullRequest:
		m.ResetPullRequest()
		return nil
	}
	return fmt.Errorf("unknown Commits edge %s", name)
}

// IssueMutation represents an operation that mutates the Issue nodes in the graph.
type IssueMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	github_id         *string
	title             *string
	created_at        *time.Time
	updated_at        *time.Time
	last_edited_at    *time.Time
	closed_at         *time.Time
	clearedFields     map[string]struct{}
	repository        *uuid.UUID
	clearedrepository bool
	done              bool
	oldValue          func(context.Context) (*Issue, error)
	predicates        []predicate.Issue
}

var _ ent.Mutation = (*IssueMutation)(nil)

// issueOption allows management of the mutation configuration using functional options.
type issueOption func(*IssueMutation)

// newIssueMutation creates new mutation for the Issue entity.
func newIssueMutation(c config, op Op, opts ...issueOption) *IssueMutation {
	m := &IssueMutation{
		config:        c,
		op:            op,
		typ:           TypeIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueID sets the ID field of the mutation.
func withIssueID(id uuid.UUID) issueOption {
	return func(m *IssueMutation) {
		var (
			err   error
			once  sync.Once
			value *Issue
		)
		m.oldValue = func(ctx context.Context) (*Issue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Issue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssue sets the old Issue of the mutation.
func withIssue(node *Issue) issueOption {
	return func(m *IssueMutation) {
		m.oldValue = func(context.Context) (*Issue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Issue entities.
func (m *IssueMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *IssueMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *IssueMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *IssueMutation) ResetGithubID() {
	m.github_id = nil
}

// SetTitle sets the "title" field.
func (m *IssueMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IssueMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IssueMutation) ResetTitle() {
	m.title = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IssueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IssueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IssueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IssueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastEditedAt sets the "last_edited_at" field.
func (m *IssueMutation) SetLastEditedAt(t time.Time) {
	m.last_edited_at = &t
}

// LastEditedAt returns the value of the "last_edited_at" field in the mutation.
func (m *IssueMutation) LastEditedAt() (r time.Time, exists bool) {
	v := m.last_edited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEditedAt returns the old "last_edited_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldLastEditedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastEditedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastEditedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEditedAt: %w", err)
	}
	return oldValue.LastEditedAt, nil
}

// ResetLastEditedAt resets all changes to the "last_edited_at" field.
func (m *IssueMutation) ResetLastEditedAt() {
	m.last_edited_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *IssueMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IssueMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IssueMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *IssueMutation) SetRepositoryID(id uuid.UUID) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *IssueMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *IssueMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *IssueMutation) RepositoryID() (id uuid.UUID, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *IssueMutation) RepositoryIDs() (ids []uuid.UUID) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *IssueMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// Where appends a list predicates to the IssueMutation builder.
func (m *IssueMutation) Where(ps ...predicate.Issue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Issue).
func (m *IssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.github_id != nil {
		fields = append(fields, issue.FieldGithubID)
	}
	if m.title != nil {
		fields = append(fields, issue.FieldTitle)
	}
	if m.created_at != nil {
		fields = append(fields, issue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, issue.FieldUpdatedAt)
	}
	if m.last_edited_at != nil {
		fields = append(fields, issue.FieldLastEditedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, issue.FieldClosedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issue.FieldGithubID:
		return m.GithubID()
	case issue.FieldTitle:
		return m.Title()
	case issue.FieldCreatedAt:
		return m.CreatedAt()
	case issue.FieldUpdatedAt:
		return m.UpdatedAt()
	case issue.FieldLastEditedAt:
		return m.LastEditedAt()
	case issue.FieldClosedAt:
		return m.ClosedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issue.FieldGithubID:
		return m.OldGithubID(ctx)
	case issue.FieldTitle:
		return m.OldTitle(ctx)
	case issue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case issue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case issue.FieldLastEditedAt:
		return m.OldLastEditedAt(ctx)
	case issue.FieldClosedAt:
		return m.OldClosedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Issue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issue.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case issue.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case issue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case issue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case issue.FieldLastEditedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEditedAt(v)
		return nil
	case issue.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Issue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Issue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Issue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueMutation) ResetField(name string) error {
	switch name {
	case issue.FieldGithubID:
		m.ResetGithubID()
		return nil
	case issue.FieldTitle:
		m.ResetTitle()
		return nil
	case issue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case issue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case issue.FieldLastEditedAt:
		m.ResetLastEditedAt()
		return nil
	case issue.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Issue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repository != nil {
		edges = append(edges, issue.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issue.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepository {
		edges = append(edges, issue.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueMutation) EdgeCleared(name string) bool {
	switch name {
	case issue.EdgeRepository:
		return m.clearedrepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueMutation) ClearEdge(name string) error {
	switch name {
	case issue.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown Issue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueMutation) ResetEdge(name string) error {
	switch name {
	case issue.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown Issue edge %s", name)
}

// PullRequestMutation represents an operation that mutates the PullRequest nodes in the graph.
type PullRequestMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	github_id         *string
	title             *string
	total_commits     *int64
	addtotal_commits  *int64
	created_at        *time.Time
	updated_at        *time.Time
	closed_at         *time.Time
	merged_at         *time.Time
	clearedFields     map[string]struct{}
	commits           map[uuid.UUID]struct{}
	removedcommits    map[uuid.UUID]struct{}
	clearedcommits    bool
	repository        *uuid.UUID
	clearedrepository bool
	done              bool
	oldValue          func(context.Context) (*PullRequest, error)
	predicates        []predicate.PullRequest
}

var _ ent.Mutation = (*PullRequestMutation)(nil)

// pullrequestOption allows management of the mutation configuration using functional options.
type pullrequestOption func(*PullRequestMutation)

// newPullRequestMutation creates new mutation for the PullRequest entity.
func newPullRequestMutation(c config, op Op, opts ...pullrequestOption) *PullRequestMutation {
	m := &PullRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePullRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPullRequestID sets the ID field of the mutation.
func withPullRequestID(id uuid.UUID) pullrequestOption {
	return func(m *PullRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PullRequest
		)
		m.oldValue = func(ctx context.Context) (*PullRequest, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PullRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPullRequest sets the old PullRequest of the mutation.
func withPullRequest(node *PullRequest) pullrequestOption {
	return func(m *PullRequestMutation) {
		m.oldValue = func(context.Context) (*PullRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PullRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PullRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PullRequest entities.
func (m *PullRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PullRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *PullRequestMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *PullRequestMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *PullRequestMutation) ResetGithubID() {
	m.github_id = nil
}

// SetTitle sets the "title" field.
func (m *PullRequestMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PullRequestMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PullRequestMutation) ResetTitle() {
	m.title = nil
}

// SetTotalCommits sets the "total_commits" field.
func (m *PullRequestMutation) SetTotalCommits(i int64) {
	m.total_commits = &i
	m.addtotal_commits = nil
}

// TotalCommits returns the value of the "total_commits" field in the mutation.
func (m *PullRequestMutation) TotalCommits() (r int64, exists bool) {
	v := m.total_commits
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommits returns the old "total_commits" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldTotalCommits(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalCommits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalCommits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommits: %w", err)
	}
	return oldValue.TotalCommits, nil
}

// AddTotalCommits adds i to the "total_commits" field.
func (m *PullRequestMutation) AddTotalCommits(i int64) {
	if m.addtotal_commits != nil {
		*m.addtotal_commits += i
	} else {
		m.addtotal_commits = &i
	}
}

// AddedTotalCommits returns the value that was added to the "total_commits" field in this mutation.
func (m *PullRequestMutation) AddedTotalCommits() (r int64, exists bool) {
	v := m.addtotal_commits
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCommits resets all changes to the "total_commits" field.
func (m *PullRequestMutation) ResetTotalCommits() {
	m.total_commits = nil
	m.addtotal_commits = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PullRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PullRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PullRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PullRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PullRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PullRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *PullRequestMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *PullRequestMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *PullRequestMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetMergedAt sets the "merged_at" field.
func (m *PullRequestMutation) SetMergedAt(t time.Time) {
	m.merged_at = &t
}

// MergedAt returns the value of the "merged_at" field in the mutation.
func (m *PullRequestMutation) MergedAt() (r time.Time, exists bool) {
	v := m.merged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMergedAt returns the old "merged_at" field's value of the PullRequest entity.
// If the PullRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestMutation) OldMergedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMergedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMergedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergedAt: %w", err)
	}
	return oldValue.MergedAt, nil
}

// ResetMergedAt resets all changes to the "merged_at" field.
func (m *PullRequestMutation) ResetMergedAt() {
	m.merged_at = nil
}

// AddCommitIDs adds the "commits" edge to the Commits entity by ids.
func (m *PullRequestMutation) AddCommitIDs(ids ...uuid.UUID) {
	if m.commits == nil {
		m.commits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.commits[ids[i]] = struct{}{}
	}
}

// ClearCommits clears the "commits" edge to the Commits entity.
func (m *PullRequestMutation) ClearCommits() {
	m.clearedcommits = true
}

// CommitsCleared reports if the "commits" edge to the Commits entity was cleared.
func (m *PullRequestMutation) CommitsCleared() bool {
	return m.clearedcommits
}

// RemoveCommitIDs removes the "commits" edge to the Commits entity by IDs.
func (m *PullRequestMutation) RemoveCommitIDs(ids ...uuid.UUID) {
	if m.removedcommits == nil {
		m.removedcommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.commits, ids[i])
		m.removedcommits[ids[i]] = struct{}{}
	}
}

// RemovedCommits returns the removed IDs of the "commits" edge to the Commits entity.
func (m *PullRequestMutation) RemovedCommitsIDs() (ids []uuid.UUID) {
	for id := range m.removedcommits {
		ids = append(ids, id)
	}
	return
}

// CommitsIDs returns the "commits" edge IDs in the mutation.
func (m *PullRequestMutation) CommitsIDs() (ids []uuid.UUID) {
	for id := range m.commits {
		ids = append(ids, id)
	}
	return
}

// ResetCommits resets all changes to the "commits" edge.
func (m *PullRequestMutation) ResetCommits() {
	m.commits = nil
	m.clearedcommits = false
	m.removedcommits = nil
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *PullRequestMutation) SetRepositoryID(id uuid.UUID) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *PullRequestMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *PullRequestMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *PullRequestMutation) RepositoryID() (id uuid.UUID, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *PullRequestMutation) RepositoryIDs() (ids []uuid.UUID) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *PullRequestMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// Where appends a list predicates to the PullRequestMutation builder.
func (m *PullRequestMutation) Where(ps ...predicate.PullRequest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PullRequestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PullRequest).
func (m *PullRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PullRequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.github_id != nil {
		fields = append(fields, pullrequest.FieldGithubID)
	}
	if m.title != nil {
		fields = append(fields, pullrequest.FieldTitle)
	}
	if m.total_commits != nil {
		fields = append(fields, pullrequest.FieldTotalCommits)
	}
	if m.created_at != nil {
		fields = append(fields, pullrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pullrequest.FieldUpdatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, pullrequest.FieldClosedAt)
	}
	if m.merged_at != nil {
		fields = append(fields, pullrequest.FieldMergedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PullRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pullrequest.FieldGithubID:
		return m.GithubID()
	case pullrequest.FieldTitle:
		return m.Title()
	case pullrequest.FieldTotalCommits:
		return m.TotalCommits()
	case pullrequest.FieldCreatedAt:
		return m.CreatedAt()
	case pullrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case pullrequest.FieldClosedAt:
		return m.ClosedAt()
	case pullrequest.FieldMergedAt:
		return m.MergedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PullRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pullrequest.FieldGithubID:
		return m.OldGithubID(ctx)
	case pullrequest.FieldTitle:
		return m.OldTitle(ctx)
	case pullrequest.FieldTotalCommits:
		return m.OldTotalCommits(ctx)
	case pullrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pullrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pullrequest.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case pullrequest.FieldMergedAt:
		return m.OldMergedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PullRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pullrequest.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case pullrequest.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case pullrequest.FieldTotalCommits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommits(v)
		return nil
	case pullrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pullrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pullrequest.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case pullrequest.FieldMergedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PullRequestMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_commits != nil {
		fields = append(fields, pullrequest.FieldTotalCommits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PullRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pullrequest.FieldTotalCommits:
		return m.AddedTotalCommits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pullrequest.FieldTotalCommits:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCommits(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PullRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PullRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PullRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PullRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PullRequestMutation) ResetField(name string) error {
	switch name {
	case pullrequest.FieldGithubID:
		m.ResetGithubID()
		return nil
	case pullrequest.FieldTitle:
		m.ResetTitle()
		return nil
	case pullrequest.FieldTotalCommits:
		m.ResetTotalCommits()
		return nil
	case pullrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pullrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pullrequest.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case pullrequest.FieldMergedAt:
		m.ResetMergedAt()
		return nil
	}
	return fmt.Errorf("unknown PullRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PullRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.commits != nil {
		edges = append(edges, pullrequest.EdgeCommits)
	}
	if m.repository != nil {
		edges = append(edges, pullrequest.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PullRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pullrequest.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.commits))
		for id := range m.commits {
			ids = append(ids, id)
		}
		return ids
	case pullrequest.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PullRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcommits != nil {
		edges = append(edges, pullrequest.EdgeCommits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PullRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pullrequest.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.removedcommits))
		for id := range m.removedcommits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PullRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcommits {
		edges = append(edges, pullrequest.EdgeCommits)
	}
	if m.clearedrepository {
		edges = append(edges, pullrequest.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PullRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case pullrequest.EdgeCommits:
		return m.clearedcommits
	case pullrequest.EdgeRepository:
		return m.clearedrepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PullRequestMutation) ClearEdge(name string) error {
	switch name {
	case pullrequest.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown PullRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PullRequestMutation) ResetEdge(name string) error {
	switch name {
	case pullrequest.EdgeCommits:
		m.ResetCommits()
		return nil
	case pullrequest.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown PullRequest edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	github_id            *string
	owner                *string
	name                 *string
	description          *string
	total_pr             *int64
	addtotal_pr          *int64
	total_issue          *int64
	addtotal_issue       *int64
	created_at           *time.Time
	updated_at           *time.Time
	pushed_at            *time.Time
	clearedFields        map[string]struct{}
	pull_requests        map[uuid.UUID]struct{}
	removedpull_requests map[uuid.UUID]struct{}
	clearedpull_requests bool
	issues               map[uuid.UUID]struct{}
	removedissues        map[uuid.UUID]struct{}
	clearedissues        bool
	done                 bool
	oldValue             func(context.Context) (*Repository, error)
	predicates           []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id uuid.UUID) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGithubID sets the "github_id" field.
func (m *RepositoryMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *RepositoryMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *RepositoryMutation) ResetGithubID() {
	m.github_id = nil
}

// SetOwner sets the "owner" field.
func (m *RepositoryMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *RepositoryMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *RepositoryMutation) ResetOwner() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *RepositoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepositoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepositoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RepositoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepositoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RepositoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[repository.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RepositoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[repository.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RepositoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, repository.FieldDescription)
}

// SetTotalPr sets the "total_pr" field.
func (m *RepositoryMutation) SetTotalPr(i int64) {
	m.total_pr = &i
	m.addtotal_pr = nil
}

// TotalPr returns the value of the "total_pr" field in the mutation.
func (m *RepositoryMutation) TotalPr() (r int64, exists bool) {
	v := m.total_pr
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPr returns the old "total_pr" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTotalPr(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalPr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalPr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPr: %w", err)
	}
	return oldValue.TotalPr, nil
}

// AddTotalPr adds i to the "total_pr" field.
func (m *RepositoryMutation) AddTotalPr(i int64) {
	if m.addtotal_pr != nil {
		*m.addtotal_pr += i
	} else {
		m.addtotal_pr = &i
	}
}

// AddedTotalPr returns the value that was added to the "total_pr" field in this mutation.
func (m *RepositoryMutation) AddedTotalPr() (r int64, exists bool) {
	v := m.addtotal_pr
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPr resets all changes to the "total_pr" field.
func (m *RepositoryMutation) ResetTotalPr() {
	m.total_pr = nil
	m.addtotal_pr = nil
}

// SetTotalIssue sets the "total_issue" field.
func (m *RepositoryMutation) SetTotalIssue(i int64) {
	m.total_issue = &i
	m.addtotal_issue = nil
}

// TotalIssue returns the value of the "total_issue" field in the mutation.
func (m *RepositoryMutation) TotalIssue() (r int64, exists bool) {
	v := m.total_issue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalIssue returns the old "total_issue" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTotalIssue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalIssue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalIssue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalIssue: %w", err)
	}
	return oldValue.TotalIssue, nil
}

// AddTotalIssue adds i to the "total_issue" field.
func (m *RepositoryMutation) AddTotalIssue(i int64) {
	if m.addtotal_issue != nil {
		*m.addtotal_issue += i
	} else {
		m.addtotal_issue = &i
	}
}

// AddedTotalIssue returns the value that was added to the "total_issue" field in this mutation.
func (m *RepositoryMutation) AddedTotalIssue() (r int64, exists bool) {
	v := m.addtotal_issue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalIssue resets all changes to the "total_issue" field.
func (m *RepositoryMutation) ResetTotalIssue() {
	m.total_issue = nil
	m.addtotal_issue = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RepositoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RepositoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RepositoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RepositoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RepositoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RepositoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPushedAt sets the "pushed_at" field.
func (m *RepositoryMutation) SetPushedAt(t time.Time) {
	m.pushed_at = &t
}

// PushedAt returns the value of the "pushed_at" field in the mutation.
func (m *RepositoryMutation) PushedAt() (r time.Time, exists bool) {
	v := m.pushed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPushedAt returns the old "pushed_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldPushedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPushedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPushedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushedAt: %w", err)
	}
	return oldValue.PushedAt, nil
}

// ResetPushedAt resets all changes to the "pushed_at" field.
func (m *RepositoryMutation) ResetPushedAt() {
	m.pushed_at = nil
}

// AddPullRequestIDs adds the "pull_requests" edge to the PullRequest entity by ids.
func (m *RepositoryMutation) AddPullRequestIDs(ids ...uuid.UUID) {
	if m.pull_requests == nil {
		m.pull_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pull_requests[ids[i]] = struct{}{}
	}
}

// ClearPullRequests clears the "pull_requests" edge to the PullRequest entity.
func (m *RepositoryMutation) ClearPullRequests() {
	m.clearedpull_requests = true
}

// PullRequestsCleared reports if the "pull_requests" edge to the PullRequest entity was cleared.
func (m *RepositoryMutation) PullRequestsCleared() bool {
	return m.clearedpull_requests
}

// RemovePullRequestIDs removes the "pull_requests" edge to the PullRequest entity by IDs.
func (m *RepositoryMutation) RemovePullRequestIDs(ids ...uuid.UUID) {
	if m.removedpull_requests == nil {
		m.removedpull_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pull_requests, ids[i])
		m.removedpull_requests[ids[i]] = struct{}{}
	}
}

// RemovedPullRequests returns the removed IDs of the "pull_requests" edge to the PullRequest entity.
func (m *RepositoryMutation) RemovedPullRequestsIDs() (ids []uuid.UUID) {
	for id := range m.removedpull_requests {
		ids = append(ids, id)
	}
	return
}

// PullRequestsIDs returns the "pull_requests" edge IDs in the mutation.
func (m *RepositoryMutation) PullRequestsIDs() (ids []uuid.UUID) {
	for id := range m.pull_requests {
		ids = append(ids, id)
	}
	return
}

// ResetPullRequests resets all changes to the "pull_requests" edge.
func (m *RepositoryMutation) ResetPullRequests() {
	m.pull_requests = nil
	m.clearedpull_requests = false
	m.removedpull_requests = nil
}

// AddIssueIDs adds the "issues" edge to the Issue entity by ids.
func (m *RepositoryMutation) AddIssueIDs(ids ...uuid.UUID) {
	if m.issues == nil {
		m.issues = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the Issue entity.
func (m *RepositoryMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the Issue entity was cleared.
func (m *RepositoryMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the Issue entity by IDs.
func (m *RepositoryMutation) RemoveIssueIDs(ids ...uuid.UUID) {
	if m.removedissues == nil {
		m.removedissues = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the Issue entity.
func (m *RepositoryMutation) RemovedIssuesIDs() (ids []uuid.UUID) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *RepositoryMutation) IssuesIDs() (ids []uuid.UUID) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *RepositoryMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.github_id != nil {
		fields = append(fields, repository.FieldGithubID)
	}
	if m.owner != nil {
		fields = append(fields, repository.FieldOwner)
	}
	if m.name != nil {
		fields = append(fields, repository.FieldName)
	}
	if m.description != nil {
		fields = append(fields, repository.FieldDescription)
	}
	if m.total_pr != nil {
		fields = append(fields, repository.FieldTotalPr)
	}
	if m.total_issue != nil {
		fields = append(fields, repository.FieldTotalIssue)
	}
	if m.created_at != nil {
		fields = append(fields, repository.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, repository.FieldUpdatedAt)
	}
	if m.pushed_at != nil {
		fields = append(fields, repository.FieldPushedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldGithubID:
		return m.GithubID()
	case repository.FieldOwner:
		return m.Owner()
	case repository.FieldName:
		return m.Name()
	case repository.FieldDescription:
		return m.Description()
	case repository.FieldTotalPr:
		return m.TotalPr()
	case repository.FieldTotalIssue:
		return m.TotalIssue()
	case repository.FieldCreatedAt:
		return m.CreatedAt()
	case repository.FieldUpdatedAt:
		return m.UpdatedAt()
	case repository.FieldPushedAt:
		return m.PushedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldGithubID:
		return m.OldGithubID(ctx)
	case repository.FieldOwner:
		return m.OldOwner(ctx)
	case repository.FieldName:
		return m.OldName(ctx)
	case repository.FieldDescription:
		return m.OldDescription(ctx)
	case repository.FieldTotalPr:
		return m.OldTotalPr(ctx)
	case repository.FieldTotalIssue:
		return m.OldTotalIssue(ctx)
	case repository.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case repository.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case repository.FieldPushedAt:
		return m.OldPushedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case repository.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case repository.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repository.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case repository.FieldTotalPr:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPr(v)
		return nil
	case repository.FieldTotalIssue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalIssue(v)
		return nil
	case repository.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case repository.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case repository.FieldPushedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_pr != nil {
		fields = append(fields, repository.FieldTotalPr)
	}
	if m.addtotal_issue != nil {
		fields = append(fields, repository.FieldTotalIssue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldTotalPr:
		return m.AddedTotalPr()
	case repository.FieldTotalIssue:
		return m.AddedTotalIssue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repository.FieldTotalPr:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPr(v)
		return nil
	case repository.FieldTotalIssue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalIssue(v)
		return nil
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldDescription) {
		fields = append(fields, repository.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldGithubID:
		m.ResetGithubID()
		return nil
	case repository.FieldOwner:
		m.ResetOwner()
		return nil
	case repository.FieldName:
		m.ResetName()
		return nil
	case repository.FieldDescription:
		m.ResetDescription()
		return nil
	case repository.FieldTotalPr:
		m.ResetTotalPr()
		return nil
	case repository.FieldTotalIssue:
		m.ResetTotalIssue()
		return nil
	case repository.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case repository.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case repository.FieldPushedAt:
		m.ResetPushedAt()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pull_requests != nil {
		edges = append(edges, repository.EdgePullRequests)
	}
	if m.issues != nil {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgePullRequests:
		ids := make([]ent.Value, 0, len(m.pull_requests))
		for id := range m.pull_requests {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpull_requests != nil {
		edges = append(edges, repository.EdgePullRequests)
	}
	if m.removedissues != nil {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgePullRequests:
		ids := make([]ent.Value, 0, len(m.removedpull_requests))
		for id := range m.removedpull_requests {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpull_requests {
		edges = append(edges, repository.EdgePullRequests)
	}
	if m.clearedissues {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgePullRequests:
		return m.clearedpull_requests
	case repository.EdgeIssues:
		return m.clearedissues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgePullRequests:
		m.ResetPullRequests()
		return nil
	case repository.EdgeIssues:
		m.ResetIssues()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}
